# 为何是RUST

​	自从我们开始使用高级语言编写操作系统以来，系统编程语言已经走了50年之久，但是事实证明，尤其是有两个问题很难破解：

* 编写安全代码很困难。 在C和C ++中正确管理内存特别困难。 数十年来，用户一直在遭受后果的困扰，其形式的安全漏洞至少可以追溯到1988年的Morris蠕虫。
* 编写多线程代码非常困难，这是利用现代计算机功能的唯一方法。 即使是经验丰富的程序员也要谨慎地使用线程代码：并发会引入大量的新错误类别，并使普通错误很难重现。

引入 Rust：一种安全的并发语言，具有 C 和 C++ 的性能。

Rust是由 Mozilla 和贡献者社区开发的一种新的系统编程语言。 与 C 和 C++ 一样，Rust使开发人员可以更好地控制内存的使用，并在语言的原始操作与其运行的机器之间保持紧密的关系，从而帮助开发人员预测其代码成本。 鲁斯特（Rust）在 Bjarne Stroustrup 的论文“抽象和 C++ 机器模型：”中表达了雄心勃勃的雄心。

>  In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better. 

除了这些，Rust还增加了自己的内存安全性和可信赖并发目标。

满足所有这些承诺的关键是Rust的所有权，转移和借用的新颖系统，在编译时进行检查，并精心设计以补充Rust灵活的静态类型系统。 所有权系统为每个值建立明确的生命周期，从而使核心语言中的垃圾收集变得不必要，并为管理其他类型的资源（如套接字和文件句柄）提供了健全而灵活的接口。 将转移值从一个所有者转移到另一个所有者，借用使代码可以临时使用一个值而不会影响其所有权。 由于以前很多程序员从未以这种形式遇到过这些功能，因此我们将在第4章和第5章中详细介绍它们。

这些相同的所有权规则也构成了Rust的可信赖并发模型的基础。大多数语言都将互斥量与要保护的数据之间的关系留给注释； Rust实际上可以在编译时检查您的代码在访问数据时是否锁定了互斥锁。大多数语言都建议您确保在将数据结构分配给另一个线程后不要自己使用数据结构； Rust会检查您是否不需要。 Rust可以防止在编译时发生数据争用。

尽管Rust具有一些面向对象的特性，但它实际上并不是一种面向对象的语言。 Rust 不是一种功能语言，尽管它确实会像功能语言一样使对计算结果的影响更加明确。 Rust 在某种程度上类似于 C 和 C++，但是这些语言的许多惯用法都不适用，因此典型的 Rust 代码与 C 或 C++ 代码并不十分相似。最好保留对Rust是哪种语言的判断，并在熟悉该语言后看看您的想法。

为了在现实环境中获得有关设计的反馈，Mozilla在Rust中开发了一种新的Web浏览器引擎Servo。 Servo的需求和Rust的目标非常吻合：浏览器必须运行良好并安全地处理不受信任的数据。 Servo使用Rust的安全并发功能使整个机器可以处理在C或C ++中不可行的任务。 实际上，Servo和Rust共同成长，Servo使用最新的新语言功能，Rust则根据来自Servo开发人员的反馈而发展。



### 类型安全

Rust是一种类型安全的语言。 但是，“类型安全”是什么意思？ 安全听起来不错，但是如何保证呢？

这是1999年C语言（称为C99）的未定义行为的定义：

> 未定义的行为
> 在使用非便携式或错误程序构造或错误数据时的行为，对此国际标准不施加任何要求

思考下面的 C 代码：

```c
int main(int argc, char **argv) {
    unsigned long a[1];
    a[3] = 0x7ffff7b36cebUL;
    return 0;
}
```

根据C99，因为此程序访问数组a末尾的元素，所以其行为是不确定的，这意味着它可以执行任何操作。 当我们电脑上运行该程序时，它会产生以下输出：

```shell
undef: Error: .netrc file is readable by others.
undef: Remove password or make file unreadable by others.
```

然后它崩溃了。 电脑中甚至都没有 .netrc 文件。 如果您自己尝试，它可能会做一些完全不同的事情。

C 编译器为此主函数生成的机器代码恰巧将数组 a 放置在返回地址前三个字的堆栈上，因此将 `0x7ffff7b36cebUL` 存储在 `a[3]` 中会更改不良main的返回地址，使其指向 C 中的代码中间 查阅.netrc文件以获取密码的标准库。 当 main 返回时，执行不是在 main 的调用者中恢复，而是在库中这些行的机器代码中恢复：

```
warnx(_("Error: .netrc file is readable by others."));
warnx(_("Remove password or make file unreadable by others."));
	goto bad;
```

在允许数组引用影响后续return语句的行为时，C 编译器完全符合标准。 未定义的操作不仅会产生未指定的结果：还可以使程序执行任何操作。

C99 标准授予编译器全部权限以使其生成更快的代码。 该标准并没有让编译器负责检测和处理像从数组末尾运行之类的奇怪行为，而是让程序员负责确保这些条件从一开始就不会出现。

从经验上讲，我们不是很擅长。 在大学读书时，研究员Peng Li 修改了 C 和 C++编译器，以使它们翻译的程序在执行某些形式的未定义行为时可以报告。 他发现几乎所有程序都可以这样做，包括那些受人尊敬的项目的程序，这些程序将其代码保持为高标准。 在实践中，不确定的行为通常会导致可利用的安全漏洞。 莫里斯蠕虫利用对前面展示的技术的详细说明，从一台机器传播到另一台机器，而这种漏洞利用至今仍在广泛使用。

根据该示例，让我们定义一些术语。 如果编写了程序，使得任何可能的执行都不会表现出未定义的行为，那么我们就说该程序定义良好。 如果某种语言的安全检查确保每个程序都定义正确，那么我们就说该语言是类型安全的。

精心编写的 C 或 C++程序可能定义正确，但是 C和C++ 的类型安全：前面显示的程序没有类型错误，但表现出未定义的行为。 相比之下，Python是类型安全的。 Python愿意花费处理器时间以比C更友好的方式检测和处理超出范围的数组索引：

```python
>>> a = [0]
>>> a[3] = 0x7ffff7b36ceb
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
>>>
```

Python引发了一个异常，这不是未定义的行为：正如我们所见，Python文档指定对 `a[3]` 的赋值应引发IndexError异常。 当然，像 ctypes 这样的模块提供了对计算机的不受限制的访问，可以将未定义的行为引入Python，但是核心语言本身是类型安全的。 Java，JavaScript，Ruby和Haskell以这种方式相似。

注意，类型安全与语言是在编译时还是在运行时检查类型无关：C 在编译时进行检查，并且不是类型安全的。 Python在运行时进行检查，并且类型安全。

具有讽刺意味的是，主流的系统编程语言 C 和 C++不是类型安全的，而大多数其他流行的语言则是。 鉴于C 和 C++用于实现系统的基础，受委托实现安全边界并与不受信任的数据接触，类型安全对于他们而言似乎是特别有价值的品质。

这是Rust旨在解决数十年的紧张关系：它既是类型安全的，又是系统编程语言。 Rust设计用于实现那些需要性能和对资源进行细粒度控制的基本系统层，但仍保证类型安全性提供的基本可预测性。 我们将在本书的后面部分详细介绍Rust如何管理这种统一。

Rust特殊的类型安全形式对多线程编程产生了令人惊讶的后果。 众所周知，并发很难在C 和 C++中正确使用。 开发人员通常仅在证明单线程代码无法实现所需性能时才转向并发。 但是Rust保证并发代码没有数据争用，在编译时捕获了互斥量或其他同步原语的任何滥用。 在Rust中，您可以使用并发性，而不必担心使除了最有成就的程序员之外的任何人都无法使用自己的代码。

从绝对安全规则出发，Rust有一个放泄阀，当您绝对必须使用原始指针时。 这就是所谓的不安全代码，尽管大多数 Rust 程序都不需要它，但我们将在第21章中说明如何使用它以及它如何适应 Rust 的整体安全方案。

与其他静态类型的语言一样，Rust的类型不仅可以防止未定义的行为，还可以做更多的事情。 精通Rust的程序员使用类型来确保值的使用不仅安全而且有意义，并且与应用程序的意图保持一致。 特别是，第11章中描述的Rust的特征和泛型提供了一种简洁，灵活且高效的方法来描述一组类型具有的共同特征，然后利用这些共同之处。

本书的目的不仅是为您提供用Rust编写程序所需的见解，还在于使该语言有效运行以确保这些程序既安全又正确，并预期它们将如何执行。 根据我们的经验，Rust是系统编程的重要一步，我们希望帮助您利用它。

